\section{Classes implementing IDataLogic interface}
\label{concr:idatalogic}

In this chapter will be exposed classes which implements
from \textit{IDataLogic} interface (exposed in details
in chapter \ref{rear:interfaces:idatalogic}).
\\
They differ on the way images
and robot's status data are collected: a concrete class
will use log file saved in a prefixed location on disk
(by using session log data),
another one will ask the server to send new images and data
thought Internet network, to implement a real-time teleguide.

\subsection{The DataLogicLogSimulator Class}
\label{concr:idatalogic:datalogiclogsimulator}

For the reasons explained in section \ref{simulator}, 
we used a Morduc simulator in order to generate and record 
test data to use during \textit{off-line} tests.
\\
For every simulation session, such data consist of:

\begin{itemize}
  \item a set of captured images, encoded in png format,
    with 632x453 pixel for each
  \item a log file reporting sampled odometry data
    for all the session
\end{itemize}

The format of the log file is the one described in section 
\ref{simulator}.
\\
The concrete \texttt{DataLogicLogSimulator} class will, then, provide 
robot's odometry data and snapshots simply by reading 
those files.
\\
Let us have a look at its declaration:

\begin{lstlisting}[caption={\texttt{DataLogic} declaration}, label={code:datalogic}, frame=trBL]
class DataLogicLogSimulator : public IDataLogic
{
 private:
  std::vector<image_data> _images_collection;
  int _index;
  int _simulation_session;
  
 public:
  DataLogicLogSimulator(int);
  ~DataLogicLogSimulator();
  void Command(int);
  void RetrieveData(robot_data *);
  void SelectImage(robot_data *, image_data *,
		   IImageSelector *);
};
\end{lstlisting}

Upon instantiation, \texttt{DataLogicLogSimulator} objects needs to be 
configured with a session identifier, to be passed to 
the constructor. 
\\
In order for the \texttt{DataLogicLogSimulator} objects to find them, 
log data must be stored within the relative path 
\texttt{../log}, with respect to the actual execution path.
Such a directory must contain a single subdirectory for every 
logged session, named \texttt{log\_$\langle$number of session$\rangle$}. 
\\
Let us now have a look at how \texttt{DataLogicLogSimulator} implements 
\texttt{IDataLogic} methods:

\begin{lstlisting}[caption={\texttt{DataLogic::Command() method}}, label={code:command_method}, frame=trBL]
void DataLogicLogSimulator::Command(int command) 
{

  // sends the command to the robot

  // in our case, just 
  // increase index to point the next line of the file
  _index++;
}
\end{lstlisting}

The \texttt{Command()} method is pretty simple in this 
implementation. Since \texttt{DataLogicLogSimulator} has been designed 
for offline testing, there's no actual command to send to the robot.
For this reason \texttt{Command()} will not take into account
the received command, the only thing that it does is 
incrementing the private attribute \texttt{\_index}, which 
will be used by \texttt{RetrieveData()} to select which line 
of the log file is to read next.

\begin{lstlisting}[caption={\texttt{DataLogic::RetrieveData()} method}, label={code:retrievedata_method}, frame=trBL]
void DataLogicLogSimulator::RetrieveData(robot_data * data)
{
  // pointer to text file containing data
  FILE * position_data;
  char line[50];
  
  std::string * line_read;
  std::string line_values[4];
  std::string position_data_name;
  std::ostringstream o;
  
  int time;
  int line_number = _index;

  // grabbed image metadata
  image_data grabbed_frame_data;
  
  o << "../log/log_" 
    << _simulation_session 
    << "/data_" 
    << _simulation_session << ".txt";

  position_data_name = o.str();

  position_data = fopen(position_data_name.c_str(), "rt");

  while(fgets(line, 50, position_data) &&
	line_number > 1)
    {
      line_number--;
    }

  line_read = new std::string(line);

  std::string buf;
  std::stringstream ss(*line_read);

  // Create vector to hold our words
  std::vector<std::string> tokens;
  
  // put token in vector element
  while (ss >> buf)
    tokens.push_back(buf);

  data->x = atof ( tokens[0].c_str() );
  data->y = atof( tokens[1].c_str() );
  data->theta = TO_DEGREES(- atof ( tokens[2].c_str() ));
  data->time = atof ( tokens[3].c_str() );

  time = (int) data->time;

  // clear the stream and 
  // add a new value to it
  o.str("");
  o.clear();
  o << "../log/log_" 
    << _simulation_session 
    << "/screenshot_" 
    << _simulation_session 
    << "_" << time << ".png";

  // fill grabbed frame metadata
  grabbed_frame_data.x = data->x;
  grabbed_frame_data.y = data->y;
  grabbed_frame_data.theta = data->theta;
  grabbed_frame_data.time = data->time;

  strcpy(grabbed_frame_data.path, o.str().c_str());

  // store the collected metadata 
  // if it's not already stored
  for (std::vector<image_data>::iterator it =
	 _images_collection.begin();
       it != _images_collection.end();
       it++)
    {
      if ( (*it).time == grabbed_frame_data.time )
	{

	  return;
	}
    }

  _images_collection.push_back(grabbed_frame_data);
  return;
}
\end{lstlisting}

What the \texttt{RetrieveData()} do is just read the line from the log 
file identified by the \texttt{\_index} private attribute of the class.
Once read, the line is \textit{parsed} and the odometry data contained 
in it is used to fill the \texttt{robot\_data} passed as argument, in 
order to return the \textit{current} robot position.
\\
Behind the curtain, \texttt{RetrieveData()} also creates a new 
\texttt{image\_data} structure, fills it with the data just 
gathered and then adds it to the \texttt{\_image\_collection} 
private attribute.
This way, every time a new line of the file is read, and, hence, 
every time a new captured image is available, the \texttt{DataLogicLogSimulator} 
is made able to keep track of it using its metadata, without actually 
loading the image - since it would be useless and time-consuming.

\begin{lstlisting}[caption={\texttt{DataLogic::SelectImage()} method}, label={code:selectimage_method}, frame=trBL]
void DataLogicLogSimulator::
SelectImage(robot_data * robot_status,
            image_data * bg_image_data,
            IImageSelector * selector)
{

  // since our data are already stored with vector,
  // we simply pass its reference
  selector -> ChooseImage(robot_status, 
                          bg_image_data, 
                          & _images_collection);
}
\end{lstlisting}

Finally, \texttt{SelectImage()} calls the \texttt{ChooseImage} method 
on an object of type \texttt{IImageSelector}, and passes it, as last 
parameter, a reference to its internal \texttt{\_images\_collection}, 
so that the selector can actually select the image to set as 
background.


\subsection{The DataLogicLogMorduc Class}
\label{concr:idatalogic:datalogiclogmorduc}

As the one exposed before, \textit{DataLogicLogMorduc} class
fetches new images and data from static textual file and images
stored in a fixed directory, but in this case data are formatted
as returned by the 3morduc's server in a real-time session. Indeed,
this class was created to develop in off-line mode the class
\textit{DataLogicMorduc}, which by Internet connection makes possible
teleguiding the real robot (see following chapter
\ref{concr:idatalogic:datalogicmorduc}).

For every simulation session, we dispose of:

\begin{itemize}
  \item a set of captured images, encoded in jpeg format,
    with 640x480 pixels each
  \item a log file for each image, reporting sampled odometry data
\end{itemize}

So, in the proper folder, there will be jpeg format file named
\textit{screenshot\_$<$uniquenumber$>$.jpg} and the coupled robot's
data status in \textit{data\_$<$uniquenumber$>$.txt}. As you can notice,
information are stored differently from one collected by the simulator
(exposed in chapter \ref{simulator}), so we need another concrete
class implementing \textit{IDataLogic} interface
(\ref{rear:interfaces:idatalogic}).


\subsection{The DataLogicMorduc Class}
\label{concr:idatalogic:datalogicmorduc}

This class allows \framework{} to teleguide the real 3morduc
robot, situated at DIEES laboratory, in Catania (Italy).
