\section{Classes implementing IDataLogic interface}
\label{concr:idatalogic}

In this chapter will be exposed classes which inherit
from \textit{IDataLogic} interface (exposed in details
in chapter \ref{rear:interfaces:idatalogic}).
\\
They differ on the way images
and robot's status data are collected: a concrete class
will use log file saved in a prefixed location on disk
(by using session log data),
another one will ask the server to send new images and data
thought Internet network, to implement a real-time teleguide.

\subsection{The DataLogicLogSimulator Class}
\label{concr:idatalogic:datalogiclogsimulator}

For the reasons explained in section \ref{log:morduc_simulator},
we used a \morduc{} simulator in order to generate and record 
test data to use during \textit{off-line} tests.
\\
For every simulation session, such data consist of:

\begin{itemize}
  \item a set of captured images, encoded in png format,
    with 632x453 pixel for each
  \item a log file reporting sampled odometry data
    for all the session
\end{itemize}

The format of the log file is the one described in section 
\ref{log:morduc_simulator}.
\\
The concrete \texttt{DataLogicLogSimulator} class will, then, provide 
robot's odometry data and snapshots simply by reading 
those files.
\\
Let us have a look at its declaration:
\\
\begin{lstlisting}[caption={\texttt{DataLogicLogSimulator} declaration},
    label={code:datalogiclogsimulator:interface}]
class DataLogicLogSimulator : public IDataLogic
{
 private:
  std::vector<image_data> _images_collection;
  int _index;
  int _simulation_session;
  
 public:
  DataLogicLogSimulator(int);
  ~DataLogicLogSimulator();
  void Command(int);
  void RetrieveData(robot_data *);
  void SelectImage(robot_data *, image_data *,
		   IImageSelector *);
};
\end{lstlisting}

Upon instantiation, \texttt{DataLogicLogSimulator} objects needs to be 
configured with a session identifier, to be passed to 
the constructor. 
In order for the \texttt{DataLogicLogSimulator} objects to find them, 
log data must be stored within the relative path 

\begin{center}
  \texttt{../log/log\_$<$\_simulation\_session$>$}
\end{center}

with respect to the actual execution path.
Such a directory must contain image and text files named and formatted
according to what stated in section \ref{log:morduc_simulator}. 
\\
Let us now have a look at how \texttt{DataLogicLogSimulator} implements 
\texttt{IDataLogic} methods:
\\
\begin{lstlisting}[caption={\texttt{DataLogicLogSimulator::Command() method}},
    label={code:datalogiclogsimulator:command}]
void DataLogicLogSimulator::Command(int command) 
{

  // sends the command to the robot

  // in our case, just 
  // increase index to point the next line of the file
  _index++;
}
\end{lstlisting}

The \texttt{Command()} method is pretty simple in this 
implementation. Since \texttt{DataLogicLogSimulator} has been designed 
for offline testing, there's no actual command to send to the robot.
For this reason \texttt{Command()} will not take into account
the received command, the only thing that it does is 
incrementing the private attribute \texttt{\_index}, which 
will be used by \texttt{RetrieveData()} to select which line 
of the log file is to read next.
\\
\begin{lstlisting}[caption={\texttt{DataLogicLogSimulator::RetrieveData()} method},
    label={code:datalogiclogsimulator:retrievedata}]
void DataLogicLogSimulator::RetrieveData(robot_data * data)
{
  // pointer to text file containing data
  FILE * position_data;
  char line[50];
  
  std::string * line_read;
  std::string line_values[4];
  std::string position_data_name;
  std::ostringstream o;
  
  int time;
  int line_number = _index;

  // grabbed image metadata
  image_data grabbed_frame_data;
  
  o << "../log/log_" 
    << _simulation_session 
    << "/data_" 
    << _simulation_session << ".txt";

  position_data_name = o.str();

  position_data = fopen(position_data_name.c_str(), "rt");

  while(fgets(line, 50, position_data) &&
	line_number > 1)
    {
      line_number--;
    }

  line_read = new std::string(line);

  std::string buf;
  std::stringstream ss(*line_read);

  // Create vector to hold our words
  std::vector<std::string> tokens;
  
  // put token in vector element
  while (ss >> buf)
    tokens.push_back(buf);

  data->x = atof ( tokens[0].c_str() );
  data->y = atof( tokens[1].c_str() );
  data->theta = TO_DEGREES(- atof ( tokens[2].c_str() ));
  data->time = atof ( tokens[3].c_str() );

  time = (int) data->time;

  // clear the stream and 
  // add a new value to it
  o.str("");
  o.clear();
  o << "../log/log_" 
    << _simulation_session 
    << "/screenshot_" 
    << _simulation_session 
    << "_" << time << ".png";

  // fill grabbed frame metadata
  grabbed_frame_data.x = data->x;
  grabbed_frame_data.y = data->y;
  grabbed_frame_data.theta = data->theta;
  grabbed_frame_data.time = data->time;

  strcpy(grabbed_frame_data.path, o.str().c_str());

  // store the collected metadata 
  // if it's not already stored
  for (std::vector<image_data>::iterator it =
	 _images_collection.begin();
       it != _images_collection.end();
       it++)
    {
      if ( (*it).time == grabbed_frame_data.time )
	{

	  return;
	}
    }

  _images_collection.push_back(grabbed_frame_data);
  return;
}
\end{lstlisting}

What the \texttt{RetrieveData()} does is just read the line from the log 
file identified by the \texttt{\_index} private attribute of the class.
Once read, the line is \textit{parsed} and the odometry data contained 
in it is used to fill the \texttt{robot\_data} passed as argument, in 
order to return the \textit{current} robot position.
\\
Be careful that last operation conceals another important duty: cast the
XY coordinates and the orientation angle (along the Y axis) returned
by the simulator environment in the proper corresponding values in OpenGL's
reference system. Lines from 45 to 47 in listing
\ref{code:datalogiclogsimulator:retrievedata} shows, in this case,
that X and Y value are not to be changed, but, on the contrary, the robot's
rotation angle has to be firstly negated (by changing its sign) and
than converted from radiants to degrees. This proves that simulator's coordinate
system differs from the one adopted in OpenGL, because not only angles
are handled with different measure scale (radiants and not degrees), but the
way of rotation is one opposite to the other.
\\
Behind the curtain, \texttt{RetrieveData()} also creates a new 
\texttt{image\_data} structure, fills it with the data just 
gathered and then adds it to the \texttt{\_image\_collection} 
private attribute.
This way, every time a new line of the file is read, and, hence, 
every time a new captured image is available, the \texttt{DataLogicLogSimulator} 
is made able to keep track of it using its metadata, without actually 
loading the image - since it would be useless and time-consuming.
\\
\begin{lstlisting}[caption={\texttt{DataLogicLogSimulator::SelectImage()} method},
    label={code:datalogiclogsimulator:selectimage}]
void DataLogicLogSimulator::
SelectImage(robot_data * robot_status,
            image_data * bg_image_data,
            IImageSelector * selector)
{

  // since our data are already stored with vector,
  // we simply pass its reference
  selector -> ChooseImage(robot_status, 
                          bg_image_data, 
                          & _images_collection);
}
\end{lstlisting}

Finally, \texttt{SelectImage()} calls the \texttt{ChooseImage} method 
on an object of type \texttt{IImageSelector}, and passes it, as last 
parameter, a reference to its internal \texttt{\_images\_collection}, 
so that the selector can actually select the image to set as 
background.


\subsection{The DataLogicLogMorduc Class}
\label{concr:idatalogic:datalogiclogmorduc}

As the one exposed before, \textit{DataLogicLogMorduc} class
fetches new images and data from static file
stored in a fixed directory, but in this case information are previously saved
not during the execution of a simulation but during
the execution of online teleguiding sessions.
\\
Logs can be created by any client which interacted with \morduc{}
server, as long as they observe the log format specified in section
\ref{log:morduc}.
\\
This class was created to develop in off-line mode the class
\textit{DataLogicMorduc}, that by Internet connection makes possible
teleguiding the real robot (see following section,
\ref{concr:idatalogic:datalogicmorduc}).

As previously stated, every log set is made-up of:

\begin{itemize}
  \item a set of captured images, encoded in jpeg format,
    with 1280x480 or 640x480 pixels each
  \item a log file reporting sampled odometry data
    for all the session
\end{itemize}

Its interface is declared as follow:
\\
\begin{lstlisting}[caption={\texttt{DataLogicLogMorduc} declaration},
    label={code:datalogiclogmorduc:interface}]
class DataLogicLogMorduc : public IDataLogic
{
 private:

  
  std::vector<image_data> _images_collection;
  int _index;
  int _log_session;
  int _index_max;

  FILE * odom_file;
  FILE * img_file;

  robot_data _last_robot_data;
  std::string _last_image_path;

  // standard libjpeg structures
  struct jpeg_decompress_struct _decomp_cinfo;
  struct jpeg_compress_struct   _comp_cinfo;
  struct jpeg_error_mgr _jerr;

  unsigned char * _raw_image;
 
  void GetOdometricData(robot_data*);
  std::string GetSingleImage();

  int ReadHalfJPEGFile();
  int WriteJPEGFile();

  
 public:
  DataLogicLogMorduc(int);
  ~DataLogicLogMorduc();
  void SelectImage(robot_data *, image_data *,
		   IImageSelector *);

  void RetrieveData(robot_data *);
  void Command(int);

};
\end{lstlisting}

Some private fields, such as
\texttt{\_log\_session}, \texttt{\_image\_collection}
and \texttt{\_index}, play
the same role as the one seen in \textit{DataLogicLosSimulator}
class. In order, they are used to identify what log set has
to be read; to collect images retrieved by the log files (each
one represented by a \texttt{image\_data} struct);
to store with an integer how much information log has already
been consumed.
\\
Log data must be saved in the following path:

\begin{center}
  \texttt{../log\_morduc/log\_$<$\_log\_session$>$}
\end{center}

always with respect to the actual execution path.
\\
New field \texttt{\_index\_max} allows to avoid some extra and
useless computation or disk access. Indeed, the integer stores
the maximum number
of images and data client can read form the log set, so
\textit{DataLogicLogMorduc}  can
return the last robot data and image previously stored, respectively,
in \texttt{\_last\_robot\_data} and \texttt{\_last\_image\_path},
when \texttt{\_index}
reaches \texttt{\_index\_max}'s value.
\\
Some private fields and methods are specialized to work with JPEG
images and are built on \textit{libjpeg} (\cite{library:libjpeg}
for official reference) library functions.
Since \textit{DataLogiLogMorduc} can deal with 1280x480
or 640x480 pixel images (the former contains both right and left
camera images, whereas the latter only the left or right one),
some supporting functions and variables are needed.
\\
When new image data are requested, \textit{DataLogiLogMorduc}
calls method \textit{GetSingleImage()}, which, based on the
\textit{\_index}'s value, reads the next image from the log set.
\\
If image's dimension is 1280x480, it calls the private method
\textit{ReadHalfJPEGFile()} in order to load only half 
picture (i.e. 640x480 pixel) in memory space pointed by variable
\textit{\_raw\_image}. Afterwards, by calling \textit{WriteJPEGFile()},
picture is read from memory to overwrite the original one the disk.
\\
In this way next time the same log session is selected \textit{DataLogicLogMorduc}
will find a 640x480 pixel JPEG image, hence no further computation
or write operation on disk has to be performed.
\\
Obviously, when the image indicated by \textit{\_index} value is
not found or with a dimension different from 1280x480 or
640x480 pixel an error is reported and the application terminate.
\\
We can now proceed to see how \textit{DataLogicLogMorduc} implements
\textit{IDataLogic} interface methods.
\\
The \textit{Command} method, as seen for the \textit{DataLogicLogSimulator}
class, is pretty simple: it has to increment \textit{\_index},
which indicate the next line in \textit{odometric.txt}
text file to read and the next image to open. It is incremented until
its value is equal to \textit{\_index\_max}.
\\
\begin{lstlisting}[caption={\texttt{DataLogicLogMorduc::Command() method}},
    label={code:datalogiclogmorduc:command}]
void DataLogicLogMorduc::Command(int command) {

  if (_index <= _index_max)
    _index++;
}
\end{lstlisting}

The \textit{RetrieveData()} method is displayed in listing
\ref{code:datalogiclogmorduc:retrievedata}:
\\
\begin{lstlisting}[caption={\texttt{DataLogicLogMorduc::RetrieveData()} method},
    label={code:datalogiclogmorduc:retrievedata}]
void DataLogicLogMorduc::RetrieveData(robot_data * data) {

  image_data grabbed_frame_data;
  std::string image_path;

  /* STEP 1: retrieve data from file (server) */
  GetOdometricData(data);

  /* STEP 2: get single image path */
  image_path = GetSingleImage();
   
  // fill grabbed frame metadata
  grabbed_frame_data.x = data->x;
  grabbed_frame_data.y = data->y;
  grabbed_frame_data.theta = data->theta;
  grabbed_frame_data.time = data->time;
  strcpy(grabbed_frame_data.path, image_path.c_str());

  /* STEP 3: store the collected metadata
     if it's not already stored */
  for (std::vector<image_data>::iterator it =
	 _images_collection.begin();
       it != _images_collection.end();
       it++)
    {
      if ( (*it).time == grabbed_frame_data.time )
	{
	  return;
	}
    }

  _images_collection.push_back(grabbed_frame_data);
  
  return;
}
\end{lstlisting}

As the reader noted, \textit{RetrieveData()} parts its duties in
three steps. First step is accomplished by calling the private method
\textit{GetOdometricData()}, which will open the odometry file, read
the line indicated by \textit{\_index} and extract the information
contained in the latter to fill the \textit{robot\_data} structure
pointed by its unique argument. The format of each text line written in
\textit{odometric.txt} can be found in section \ref{log:morduc}.
\\
\textit{GetOdometricData()} is also responsible for mapping XY
coordinates and rotation angle theta, retrieved by the log
odometry file written by the \morduc{} server, in the matching values
to provide to the OpenGL's reference system. The XY coordinates returned
by \morduc{} are expressed in meters and have to be increased hundred
times in order to produce a meaningful robot's movement within the
synthesized OpenGL space. A single unit of measure in the latter stands
in fact for one centimetre.
\\
Furthermore, the coordinate conversion process (performed by  
\textit{GetOdometricData()} and hence not shown in listing 
\ref{code:datalogiclogmorduc:retrievedata}) inverts the Y axis sense
by changing the sign of every Y value read from log; at last, the
rotation angle theta is converted from radiant to degrees, because
\morduc{} and OpenGL use different notations.
\\
To sum up, the coordinate system used by \morduc{} server presents,
in reference to the one adopted by OpenGL, 1. a smaller unit of
measure, 2. the Y axis increasing with opposite sense, 3. rotation
angle expressed in radiants and not in degrees.
\\
Note that matching the source data coordinate system in the OpenGL one
depends heavily on the  kind of source we are dealing with. In previous
section, where data were collected from the simulator log files, conversion
was
performed in a totally different way because simulator implements
its own coordinate system.
\\
Back to \textit{RetrieveData()} method, in second step a call to
\textit{GetSingleImage()} is performed,
returning a struct pointing to the new image.
At last, the previous \textit{image\_data} struct is insert to the set
of available images, by adding it to the \textit{\_image\_collection}
vector.
\\
\textit{SelectImage}'s code is, once again, completely equal to the one
presented in the previous section. It refers whole the computation to the
\textit{ChooseImage()} method implemented by the instance pointed by
its last argument.
\\
\begin{lstlisting}[caption={\texttt{DataLogicLogMorduc::SelectImage()} method},
    label={code:datalogiclogmorduc:selectimage}]
void DataLogicLogMorduc::
SelectImage(robot_data * robot_status,
            image_data * bg_image_data,
            IImageSelector * calculator) {

  calculator->ChooseImage(robot_status, bg_image_data,
                          &_images_collection);
}

\end{lstlisting}

\textit{ChooseImage()} will select the proper image to render as texture
by knowing the actual robot position (fist parameter) and the set of available
image shot by the robot during its path. The chosen image is returned by filled
the structure pointed by its second parameter.
\\
Section \ref{concr:iimageselector} will cover in details algorithms and
features implemented by different kind of \textit{ChooseImage()} methods.

\subsection{The DataLogicMorduc Class}
\label{concr:idatalogic:datalogicmorduc}

This class allows \framework{} to teleguide the real \morduc{}
robot, situated at DIEES laboratory, in Catania (Italy).
\\
\textit{DataLogicMorduc} originates several of its features 
from the \textit{DataLogicLogMorduc}, exposed earlier in
\ref{concr:idatalogic:datalogiclogmorduc}. Main differences
relies on the way new data are retrieved, since they are not
statically saved in log file but dynamically created and sent
from the server to the client through the Internet network.
\\
\textit{DataLogicMorduc} can be thought of as the final
stage of a development project whose primary aim was that
to teleguide a real mobile robot by remote control.
\\
The
robot concerned is the mobile-platform \morduc{}, we can
establish a communication channel with through simple
HTTP requests and responses. Details about accepted
commands and returned replies can be found in 
in section \ref{intro:3morduc:communication}, here we
remind briefly that \morduc{} can be controlled
by requesting different resources (i.e. URLs) to the server.
\\
A set of specific URLs allows to drive the robot in remote
environment, changing its position forward or backward and
steering in the left or right direction. Another set
of resources are instead provided to simply retrieve robot's
data without altering its status.
\\
\textit{DataLogicMorduc} class bases its functionalities
on two fundamental libraries, named \textit{libjpeg} and
\textit{curlpp}. The former, already mentioned previously,
offers the means for handling JPEG images, which is the codec
server compresses the images with before sending them to
client.
\\
The latter is a C++ wrapper for the widely used
\textit{libcurl}. It exposes some classes and data structure
that allows sending HTTP request and processing the relative
response within few code lines.
\\
Official references about the libraries cited above can be
found in \cite{library:libjpeg} (\textit{libjpeg}) and
\cite{library:curlpp} (\textit{curlpp}).
\\
Interface exposed by \textit{DataLogicMorduc} is reported in
listing \ref{code:datalogicmorduc:interface}.
\\
\begin{lstlisting}[caption={\texttt{DataLogicLogMorduc} declaration},
    label={code:datalogicmorduc:interface}]
class DataLogicMorduc : public IDataLogic
{
  

 private:

  std::vector<image_data> _images_collection;
  int _index;
  
  FILE * odom_file;
  FILE * img_file;

  std::string _path_server;
  std::string _path_data;

  HTTPFunctor _http_functor;
  
 public:
  DataLogicMorduc(const char*, const char*);
  ~DataLogicMorduc();
  void SelectImage(robot_data *, image_data *,
		   IImageSelector *);

  void RetrieveData(robot_data *);

  void Command(int);

};
\end{lstlisting}

As requested, it implements \textit{IDataLogic} interface and
hence presents its three public methods along with class constructor
and destructor.
\\
To create a new class instance, client has to specify
two string parameters. Their values indicate, in order, the IP
address or URL where the server is located and the path of an
existing folder. \textit{\_path\_server} and \textit{\_path\_data}
private fields help to store them, since their value are needed
several times during object life.
\\
The latter is used to save data provided by the server during the
teleguiding session. \framework{} needs to store images obtained
in online mode in order to simulate the \textit{exocentric} point
of view: an image shot earlier by the egocentric camera must be
selected by the core algorithm every time a robot change its position.
The chosen image is then employed as texture by OpenGL, with the aim
to recreate the real world within virtual space.
\\
Images are saved in the specified path, each one according to the
following notation, thanks to the \textit{img\_file} pointer
shown in previous listing.

\begin{center}
  \texttt{$<$user\_path$>$/img$<$index\_value$>$.jpg}
\end{center}

Obviously, integer \textit{\_index} starts counting from one and is
incremented every time new image and robot data are received by the
client. By means of \textit{libjpeg} library, image obtained is
firstly loaded in memory (i.e. dynamic memory), and then only half
its content its written to hard disk: \framework{} exploits only
left or right camera image, but server returns (through HTTP body
response) both images through a single 1280x480 pixels JPEG image,
so \textit{DataLogicMorduc} saves directly 640x480 picture in order
to avoid future further computation.
\\
Besides, each image is represented by a \textit{image\_data}
structure collected in vector \textit{\_images\_collection}. This
collection allows to quickly access information regarding the
available images, since every element can be thought of as a pointer
to the real images (we remind that every struct contains, among
other information, the absolute path referring to the image).
\\
Even thought \framework{} would not need to save other data aside
from pictures frame, \textit{DataLogicMorduc} creates, always on
the specified directory, a text file containing odometry data retrieved
along with each image. Its absolute path will be:

\begin{center}
  \texttt{$<$user\_path$>$/odometric.txt}
\end{center}

File pointer \textit{odom\_file} serves for the purpose. Storing
odometric information proves to be extremely useful because,
together with camera images, they form new log data client can
based its future computation on by using the \textit{DataLogiLogMorduc}
class. The advantages of log data (formatted in a standard way)
has been widely exposed through
this document, for details see section \ref{log}.
\\
Last, but not least, \textit{\_http\_functor} field is used to
collect data coming from Internet network, i.e. response sent from
server. It performs the role of a 'functor`, deeper explained in
following subsection (\ref{}).
\\
As usual, we can now proceed to examine in detail how \textit{IDataLogic}
virtual method are implement. To begin with, \textit{Command()} code is
displayed.
\\
\begin{lstlisting}[caption={\texttt{DataLogicMorduc::Command() method}},
    label={code:datalogicmorduc:command}]
void DataLogicMorduc::Command(int command) {

  // send the command to the robot
  std::string command_URL;
  std::ostringstream os;

  switch (command) {

  case FORWARD:
    command_URL = _path_server + "stereo.fow1.jpg";
    break;

  case BACKWARD:
    command_URL = _path_server + "stereo.bak1.jpg";
    break;

  case RIGHT:
    command_URL = _path_server + "stereo.rgt.jpg";
    break;

  case LEFT:
    command_URL = _path_server + "stereo.lft.jpg";
    break;

  default:
    std::cout << "Unknown command: " << command
	      << std::endl << "Program will terminate."
	      << std::endl;

    exit(1);
  }
 
  try {

    curlpp::Cleanup cleaner;
    curlpp::Easy request;

    // header options' list
    std::list<std::string> headers;
    headers.push_back("User-Agent: REAR client"); 

    // Setting request options
    request.setOpt(new curlpp::options::Url(command_URL));
    request.setOpt(new curlpp::options::Verbose(false));
    request.setOpt(new curlpp::options::HttpHeader(headers));
    // redirect response to os
    request.setOpt(new curlpp::options::WriteStream(&os));    
    
    // send request
    request.perform();    
  }
       
  // increase index to point the next line of the file
  _index++;

}
\end{lstlisting}

Unlike the other class implementing \textit{IDataLogic} interface
exposed so far, \textit{DataLogicMorduc}'s command method takes
in account its integer parameter because its final aim is to
\textit{really} teleguide the robot: next robot's status it is
not been determinated and written in a log file, but it depends
on which command teleoperator asks to execute.
\\
For one of each available command (go forward, go backward, turn right
and turn left) a specific resource must be requested to the connected
\morduc{} server. URL is built by merging server's address (stored
in \textit{\_path\_server}) with a string indicating the requested
command (see chapter \ref{intro:3morduc:communication} for a complete
list of all possible values).
\\
After constructing URL, \textit{Command()} prepares an HTTP
request by means of \textit{curlpp} objects (lines 38 to 50 in listing
\ref{code:datalogicmorduc:command}). Therefore, the request is sent
simply by invoking the \textit{perform()} method of the
\textit{curlpp::Easy} object. This few lines of code evince
\textit{curlpp}'s potential to largely reduce programmer's effort in
dealing with HTTP protocol (as well as many other Internet protocol
\cite{library:curlpp}).
\\
At last, \textit{\_index} value is incremented to uniquely identify
next saved image.
\\
\textit{RetrieveData()} subdived its operations in three steps. Its
code is shown in following listing, but in order to
focus reader's attention on chief points, some control code (e.g. checking
if opening a file returns without errors) has been deleted.
\\
\begin{lstlisting}[caption={\texttt{DataLogicMorduc::RetrieveData()} method},
    label={code:datalogicmorduc:retrievedata}]
void DataLogicMorduc::RetrieveData(robot_data * data) {

  std::ostringstream o;
  // img path
  o << _path_data << "img" << _index << ".jpg";

  std::string command_URL = _path_server + "stereo.jpg";
  std::string image_path = o.str();
  std::string line_read;

  image_data grabbed_frame_data;
  
  // STEP 1: REQUEST DATA FROM SERVER

  try {

    curlpp::Cleanup cleaner;
    curlpp::Easy request;

    _http_functor.ResetFunctor();
    
    // Set the writer callback to enable cURL 
    // to write result in a memory area
    curlpp::types::WriteFunctionFunctor
                   functor_body(&_http_functor, 
		                &HTTPFunctor::
                                WriteHTTPBodyCallback);
      
    curlpp::types::WriteFunctionFunctor
                   functor_header(&_http_functor, 
				  &HTTPFunctor::
                                  WriteHTTPHeaderCallback);
    
    // header options' list
    std::list<std::string> headers;
    headers.push_back("User-Agent: REAR client"); 
      
    // Setting request options
    request.setOpt(new curlpp::options::
                     Url(command_URL));
    request.setOpt(new curlpp::options::
                     Verbose(false));
    request.setOpt(new curlpp::options::
                     WriteFunction(functor_body));
    request.setOpt(new curlpp::options::
                     HeaderFunction(functor_header));
    request.setOpt(new curlpp::options::
                     HttpHeader(headers));
        
    // send request
    request.perform();
      
    line_read = _http_functor.GetOdometryString();
    _http_functor.CreateImage(image_path.c_str());
  }
  
  // STEP 2: WRITE ODOMETRIC DATA TO FILE
  // AND FILL ROBOT DATA
  
  // open new file per odometry data
  std::string odom_file_path = _path_data  + "odometric.txt";
  odom_file = fopen(odom_file_path.c_str(), "at");  

  fputs(line_read.c_str(), odom_file);
  fclose(odom_file);

  FillOdometricData(line_read, data);

  // STEP 3: insert image in collection
   
  // fill grabbed frame metadata
  grabbed_frame_data.x = data->x;
  grabbed_frame_data.y = data->y;
  grabbed_frame_data.theta = data->theta;
  grabbed_frame_data.time = data->time;

  strcpy(grabbed_frame_data.path, image_path.c_str());

  // store the collected metadata if it's not already stored
  for (std::vector<image_data>::iterator it =
	 _images_collection.begin();
       it != _images_collection.end();
       it++)
    {
      if ( (*it).time == grabbed_frame_data.time )
	{
	  return;
	}
    }

  _images_collection.push_back(grabbed_frame_data);
  
  return;
}
\end{lstlisting}

First of all, the URL of the resource requested is built (line 7):
in these case we want to receive only image and odometry data
(see \ref{intro:3morduc:communication} for further details about
\morduc{}'s served URLs).
\\
Next, first step set some options in a \textit{curlpp::Easy} object
before sending the request with its \textit{perform()} method. Among
these, the callback function are indicated for managing HTTP response
header and body. Both callback are implemented by the functor
\textit{HTTPFunctor} class, exposed later. When the \textit{perform()}
method is called, a synchronous call is done and the execution proceeds
only when all response data has been received.
\\
Since HTTP header and body will be received in an asynchronous mode
(data through network are parted in package), the callback will be
called every time a new piece of information is received.
\textit{functor\_body} (declared from line 24) manages data belonging
to HTTP body, whereas \textit{functor\_header} (declared from line 29)
manages data belonging HTTP header.
\\
Functor's task is to proper store received data as long as they arrive.
When the execution resumes from the \textit{perform()} method (line 52),
\textit{RetrieveData()} can complete its first step by asking
\textit{\_http\_functor} to return the odometry string returned by the server
(originally contained in HTTP header) and to save image contained in
HTTP body into JPEG file (better, half the image, as previously stated).
\\
In second step odometry text line is written in \textit{odometric.txt},
and then the same string is passed to the private \textit{FillOdometricData()}
method in order to extract its information and fill the pointed
\textit{robot\_data} structure. Only one note has to be done: as seen
in previous classes implementing \textit{IDataLogic} interface, a
proper mapping between source data system reference and OpenGL coordinate
system has to be performed.
\\
In this case, the operation are the same already exposed in previous section,
for \textit{DataLogicLogMorduc}. In synthesis, we have to 1. multiple X and Y
value by 100, 2. change the sign of  Y values, 3. change angle of rotation
measure from radiants to degrees. For further details we refer to section
\ref{concr:idatalogic:datalogiclogmorduc}.
\\
Step number three consists of the common piece of code met several
times in this document. A new \textit{image\_data} struct, representing
the received and locally stored image, is created and inserted in
\textit{\_image\_collection} set.
\\
Last public method, \textit{SelectImage()} refers the chosen of the image
to put as texture completely to the passed instance of
\textit{IImageSelector}, which will fill the pointed \textit{image\_data}
with a picture contained in \textit{\_image\_collection}.
\\
\begin{lstlisting}[caption={\texttt{DataLogicMorduc::SelectImage()} method},
    label={code:datalogicmorduc:selectimage}]
void DataLogicMorduc::SelectImage(robot_data * robot_status,
                                  image_data * bg_image_data,
				  IImageSelector * calculator) {

  calculator->ChooseImage(robot_status, bg_image_data,
                          &_images_collection);
}

\end{lstlisting}

\subsubsection{The HTTPFunctor Class}
\label{concr:idatalogic:datalogicmorduc:httpfunctor}

Some notes about functors in general and HTTPFunctor class
in specific.
